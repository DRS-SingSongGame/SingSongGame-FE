"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";
import GameHeader from "./GameHeader";
import GameChat from "./GameChat";
import GameScoreboard from "./GameScoreboard";
import GameInfo from "./GameInfo";
import GameResultModal from "./GameResultModal";
import { connectGameSocket, disconnectGameSocket } from "@/lib/gameSocket";
import { sendGameMessage } from "@/lib/gameSocket";
import { Sparkles, Music, Mic, Trophy, Star, Zap, Bot, Rocket, Target, Crown } from "lucide-react";
import api from "@/lib/api";

interface FlatLyricsGameProps {
  user: any;
  room: any;
  players: any[];
  onBack: () => void;
  onGameEnd: (results: any[]) => void;
}

interface Song {
  id: number;
  title: string;
  artist: string;
  hint?: string;
}

interface GameState {
  currentRound: number;
  maxRound: number;
  timeLeft: number;
  isReading: boolean;
  currentSong: Song | null;
  scores: { [playerId: string]: number };
  correctAnswer: string | null;
  correctArtist: string | null;
  roundWinner: string | null;
  showCorrectAnswer: boolean;
  showParticles: boolean;
  audioLevel: number;
  robotSpeaking: boolean;
  scoreAnimations: { id: string; score: number; x: number; y: number }[];
}

interface ChatMessage {
  id: number;
  playerId: string;
  playerName: string;
  message: string;
  time: string;
  isCorrect?: boolean;
  isSystem?: boolean;
}

interface Particle {
  id: number;
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  color: string;
}

const FlatLyricsGame = ({ user, room, players, onBack, onGameEnd }: FlatLyricsGameProps) => {
  const [gameState, setGameState] = useState<GameState>({
    currentRound: 0,
    maxRound: 0,
    timeLeft: 60,
    isReading: false,
    currentSong: null,
    scores: {},
    correctAnswer: null,
    correctArtist: null,
    roundWinner: null,
    showCorrectAnswer: false,
    showParticles: false,
    audioLevel: 0,
    robotSpeaking: false,
    scoreAnimations: [],
  });

  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  const [chatInput, setChatInput] = useState("");
  const [showResults, setShowResults] = useState(false);
  const [gameOver, setGameOver] = useState(false);
  const [audio, setAudio] = useState<HTMLAudioElement | null>(null);
  const [particles, setParticles] = useState<Particle[]>([]);
  const [robotMessages, setRobotMessages] = useState<string[]>([]);
  const [showRobot, setShowRobot] = useState(false);
  const [showHintAnimation, setShowHintAnimation] = useState<string | null>(null);
  // ÌûåÌä∏ Í≥†Ï†ï ÏÉÅÌÉú
  const [fixedHint, setFixedHint] = useState<string | null>(null);

  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const animationFrameRef = useRef<number | null>(null);

  // Î°úÎ¥á Î©îÏãúÏßÄ ÏÉùÏÑ±
  const generateRobotMessage = () => {
    const messages = [
      "ÏïàÎÖïÌïòÏÑ∏Ïöî! Ï†ÄÎäî AI ÎÖ∏Îûò Î°úÎ¥áÏûÖÎãàÎã§! ü§ñ",
      "ÎÖ∏ÎûòÎ•º Î∂ÄÎ•º Ï§ÄÎπÑÍ∞Ä ÎêòÏóàÏñ¥Ïöî! üéµ",
      "Í∞ÄÏÇ¨Î•º Ïûò Îì§Ïñ¥Î≥¥ÏÑ∏Ïöî! üé§",
      "Ï†ïÎãµÏùÑ ÎßûÏ∂∞Î≥¥ÏÑ∏Ïöî! üéØ",
      "ÌõåÎ•≠Ìï¥Ïöî! Ï†ïÎãµÏûÖÎãàÎã§! üéâ",
      "Îã§Ïùå ÎùºÏö¥ÎìúÎ°ú ÎÑòÏñ¥Í∞ëÎãàÎã§! üöÄ",
      "Ï†êÏàòÍ∞Ä Ïò¨ÎùºÍ∞ÄÍ≥† ÏûàÏñ¥Ïöî! ‚¨ÜÔ∏è",
      "Ï†ïÎßê ÏûòÌïòÏãúÎÑ§Ïöî! üëè",
      "ÎÖ∏ÎûòÎ•º Îçî Î∂ÄÎ•ºÍπåÏöî? üé∂",
      "ÌûåÌä∏Î•º Ïûò ÌôúÏö©ÌïòÏÑ∏Ïöî! üí°"
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  };

  // Ï†êÏàò Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∂îÍ∞Ä
  const addScoreAnimation = (playerId: string, score: number, x: number, y: number) => {
    const newAnimation = {
      id: `${playerId}-${Date.now()}`,
      score,
      x,
      y
    };
    setGameState(prev => ({
      ...prev,
      scoreAnimations: [...prev.scoreAnimations, newAnimation]
    }));

    setTimeout(() => {
      setGameState(prev => ({
        ...prev,
        scoreAnimations: prev.scoreAnimations.filter(anim => anim.id !== newAnimation.id)
      }));
    }, 2000);
  };

  // Ïò§ÎîîÏò§ ÏãúÍ∞ÅÌôî Ìö®Í≥º Ï†úÍ±∞

  // ÌååÌã∞ÌÅ¥ Ìö®Í≥º
  useEffect(() => {
    if (!gameState.showParticles) return;

    const interval = setInterval(() => {
      setParticles(prev => {
        const newParticles = prev
          .map(p => ({ ...p, life: p.life - 1, x: p.x + p.vx, y: p.y + p.vy }))
          .filter(p => p.life > 0);

        if (Math.random() < 0.5) {
          newParticles.push({
            id: Date.now() + Math.random(),
            x: Math.random() * window.innerWidth,
            y: window.innerHeight,
            vx: (Math.random() - 0.5) * 6,
            vy: -Math.random() * 4 - 2,
            life: 80,
            color: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'][Math.floor(Math.random() * 7)]
          });
        }

        return newParticles;
      });
    }, 30);

    return () => clearInterval(interval);
  }, [gameState.showParticles]);

  // Î°úÎ¥á Î©îÏãúÏßÄ Ìö®Í≥º
  useEffect(() => {
    if (gameState.robotSpeaking) {
      const message = generateRobotMessage();
      setRobotMessages(prev => [...prev, message]);
      
      setTimeout(() => {
        setGameState(prev => ({ ...prev, robotSpeaking: false }));
      }, 3000);
    }
  }, [gameState.robotSpeaking]);

  // ÏäπÎ¶¨ Ìö®Í≥º
  const triggerVictoryEffect = () => {
    setGameState(prev => ({ ...prev, showParticles: true, robotSpeaking: true }));
    setShowRobot(true);

    setTimeout(() => {
      setGameState(prev => ({ ...prev, showParticles: false }));
      setShowRobot(false);
    }, 4000);
  };

  // ÌûåÌä∏ Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î∞ç Ï†úÏñ¥ (ÎùºÏö¥Îìú ÏãúÏûë Ïãú)
  useEffect(() => {
    if (gameState.currentSong !== null && gameState.isReading) {
      if (gameState.currentSong.hint) {
        setTimeout(() => {
          setShowHintAnimation(`üí° ÌûåÌä∏: ${gameState.currentSong!.hint}`);
          setTimeout(() => {
            setShowHintAnimation(null);
            setFixedHint(`üí° ÌûåÌä∏: ${gameState.currentSong!.hint}`);
          }, 2000); // 2Ï¥à ÌõÑ ÏÇ¨ÎùºÏßê + Í≥†Ï†ï
        }, 10000); // ÎùºÏö¥Îìú ÏãúÏûë 10Ï¥à ÌõÑ ÌûåÌä∏ ÌëúÏãú
      }
    } else {
      setShowHintAnimation(null);
      setFixedHint(null);
    }
  }, [gameState.currentSong?.id, gameState.isReading]);

  useEffect(() => {
    if (!room || !room.roomId) return;
  
    // 1. Ï¥àÍ∏∞ Ï†êÏàò ÏÑ§Ï†ï
    const initialScores = players.reduce((acc, player) => {
      acc[player.id] = 0;
      return acc;
    }, {} as { [key: string]: number });
    setGameState((prev) => ({ ...prev, scores: initialScores }));
  
    // 2. Í≤åÏûÑ ÏãúÏûë POST ÏöîÏ≤≠
   
  }, [room?.roomId]);

  useEffect(() => {
    if (!gameState.isReading || gameState.timeLeft <= 0) return;
  
    const interval = setInterval(() => {
      setGameState(prev => ({
        ...prev,
        timeLeft: prev.timeLeft - 1,
      }));
    }, 1000);
  
    return () => clearInterval(interval);
  }, [gameState.isReading, gameState.timeLeft]);

  const handleRoundStart = (payload: any) => {
    console.log("payload Îç∞Ïù¥ÌÑ∞", payload)
    const song = payload.song;
    console.log(song)
    const roundNumber = song.round;
    const playbackStartTime = payload.playbackStartTime;
  
    setGameState((prev) => ({
      ...prev,
      currentRound: roundNumber,
      maxRound: song.maxRound,
      currentSong: song,
      timeLeft: 60,
      correctAnswer: null,
      correctArtist: null,
      roundWinner: null,
      isReading: true,
      showCorrectAnswer: false,
      robotSpeaking: true,
    }));

    setShowRobot(true);
  

  
    // üîÅ Í∏∞Ï°¥ setAudio() ÎåÄÏã† ref ÏÇ¨Ïö©
    const newAudio = new Audio(`/api/song/tts?songId=${song.id}`);
    audioRef.current = newAudio;
  
    newAudio.oncanplaythrough = () => {
      
      const delay = playbackStartTime - Date.now();
      console.log('playbackStartTime:', playbackStartTime);
      console.log('ÌòÑÏû¨ ÏãúÍ∞Ñ:', Date.now());
      console.log('Í≥ÑÏÇ∞Îêú delay:', delay);
      
      if (delay > 0) {
        console.log(`‚è±Ô∏è ${delay}ms ÌõÑ Ïò§ÎîîÏò§ Ïû¨ÏÉù`);
        setTimeout(() => {
          newAudio.play().then(() => console.log("‚úÖ Ïò§ÎîîÏò§ Ïû¨ÏÉù ÏãúÏûëÎê®"));
        }, delay);
      } else {
        newAudio.play().then(() => console.log("‚úÖ Ïò§ÎîîÏò§ Ïû¨ÏÉù ÏãúÏûëÎê®"));
      }
    };
  
    newAudio.onended = () => {
      console.log("üéµ Ïò§ÎîîÏò§ Ïû¨ÏÉù Ï¢ÖÎ£åÎê®");
      setGameState((prev) => ({ ...prev, isReading: false }));
      setShowRobot(false);
      if (user.id === room.hostId) {
        notifyTtsFinished(room.roomId);
      }
    };
  };

  const notifyTtsFinished = (roomId : Number) => {
  fetch(`/api/ai-game/${room.roomId}/tts-finished`, {
    method: "POST",
  })
    .then(() => console.log("‚úÖ TTS Ï¢ÖÎ£å ÏïåÎ¶º Ï†ÑÏÜ°Îê®"))
    .catch((err) => console.error("‚ùå TTS Ï¢ÖÎ£å ÏïåÎ¶º Ïã§Ìå®", err));
};

  const handleAnswerCorrect = (data: any) => {
    const { playerId, playerName, title, artist, score } = data;
    
    console.log('Ï†ïÎãµ Îç∞Ïù¥ÌÑ∞:', data);
    console.log('playerId:', playerId);
    console.log('players:', players);
    console.log('Ï∞æÏùÄ ÌîåÎ†àÏù¥Ïñ¥:', players.find(p => p.id === playerId));
   
    // ‚úÖ Ï†ïÎãµÏûêÎäî Ïò§ÎîîÏò§ Î©àÏ∂îÍ∏∞
    if (audioRef.current) {
      window.speechSynthesis.cancel();
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
      audioRef.current.onended = null;
      audioRef.current.src = "";
    }

    if (user.id === room.hostId) {
      notifyTtsFinished(room.roomId);
    }

    // Ï†êÏàò Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∂îÍ∞Ä
    addScoreAnimation(playerId, score, Math.random() * window.innerWidth, Math.random() * window.innerHeight);

    // ÏäπÎ¶¨ Ìö®Í≥º Ìä∏Î¶¨Í±∞
    triggerVictoryEffect();

    setGameState((prev) => ({
      ...prev,
      roundWinner: playerId,
      correctAnswer: title,
      correctArtist: artist,
      isReading: false,
      showCorrectAnswer: true,
      scores: {
        ...prev.scores,
        [playerId]: (prev.scores[playerId] || 0) + score,
      },
    }));



    // Ï†ïÎãµ ÏÇ¨Ïö¥Îìú Ïû¨ÏÉù
    const aiSound = new Audio('/audio/ai.wav');
    aiSound.volume = 0.5; // Î≥ºÎ•®ÏùÑ 50%Î°ú ÏÑ§Ï†ï
    aiSound.play().catch(err => console.error('ai.wav Ïû¨ÏÉù Ïã§Ìå®:', err));
  };

  const handleGameEnd = (data: any) => {
    setGameOver(true);
    setShowResults(true);
    
    // Í≤åÏûÑ Í≤∞Í≥º ÏÇ¨Ïö¥Îìú Ïû¨ÏÉù
    const aiResultSound = new Audio('/audio/airesult.wav');
    aiResultSound.volume = 0.5; // Î≥ºÎ•®ÏùÑ 50%Î°ú ÏÑ§Ï†ï
    aiResultSound.play().catch(err => console.error('airesult.wav Ïû¨ÏÉù Ïã§Ìå®:', err));
    
    // onGameEnd(data);
  };

  const handleCloseResult = async () => {
    setShowResults(false);
    try {
      await api.delete(`/api/room/${room.roomId}/leave`);
    } catch (e) {
      // Ïã§Ìå®Ìï¥ÎèÑ Í∑∏ÎÉ• Î°úÎπÑÎ°ú Ïù¥Îèô
    }
    window.location.href = '/lobby';
  };



  useEffect(() => {
  
    const initialScores = players.reduce((acc, player) => {
      acc[player.id] = 0;
      return acc;
    }, {} as { [key: string]: number });
  
    setGameState((prev) => ({ ...prev, scores: initialScores }));
  
    const callbacks = {
      onConnect: () => {
        if (user.id === room.hostId) {
          console.log("üëë ÌòÑÏû¨ Ïú†Ï†ÄÍ∞Ä Î∞©Ïû•ÏûÖÎãàÎã§. Í≤åÏûÑ ÏãúÏûë ÏöîÏ≤≠ÏùÑ Î≥¥ÎÉÖÎãàÎã§.");
          fetch(`/api/ai-game/${room.roomId}/start`, {
            method: "POST",
          })
            .then((res) => {
              if (!res.ok) throw new Error("Í≤åÏûÑ ÏãúÏûë Ïã§Ìå®");
              console.log("‚úÖ Í≤åÏûÑ ÏãúÏûë ÏöîÏ≤≠ ÏÑ±Í≥µ");
            })
            .catch((err) => {
              console.error("‚ùå Í≤åÏûÑ ÏãúÏûë Ïã§Ìå®", err);
            });
        } else {
          console.log("üö´ Î∞©Ïû•Ïù¥ ÏïÑÎãàÎØÄÎ°ú Í≤åÏûÑ ÏãúÏûë ÏöîÏ≤≠ÏùÑ Î≥¥ÎÇ¥ÏßÄ ÏïäÏùå");
        }
      },
      onMessage: (data: any) => {
        console.log("[WebSocket ÏàòÏã†]", data);
        const msg: ChatMessage = {
          id: Date.now(),
          playerId: data.senderId,
          playerName: data.senderName,
          message: data.message,
          time: new Date(data.timestamp).toLocaleTimeString("ko-KR", {
            hour: "2-digit",
            minute: "2-digit",
          }),
          isSystem: false,
        };
        setChatMessages((prev) => [...prev, msg]);
      },
      onRoundStart: handleRoundStart,
      onAnswerCorrect: handleAnswerCorrect,
      onGameEnd: handleGameEnd,
      onError: (err: any) => console.error("ÏÜåÏºì Ïò§Î•ò", err),
      onGameStartCountdown: (res: any) => console.log("Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë", res),
    };
  
    connectGameSocket(room.roomId.toString(), callbacks, true);
  
    return () => {
      console.log("üõë disconnectGameSocket Ìò∏Ï∂úÎê®");
      disconnectGameSocket();
    };
  }, [room?.roomId]);

  const handleChatSubmit = () => {
    if (!chatInput.trim()) return;

    const trimmedMessage = chatInput.trim();
  
    // Ïú†Ìã∏ Ìï®ÏàòÎ°ú Ï†ÑÏÜ° Ï≤òÎ¶¨ ÏúÑÏûÑ
    sendGameMessage(
      room.roomId,
      user.id,
      user.nickname,
      chatInput.trim(),
      true
    );

    fetch(`/api/ai-game/${room.roomId}/answer`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ answer: trimmedMessage, timeLeft: gameState.timeLeft }),
    }).catch((err) => {
      console.error("‚ùå Ï†ïÎãµ Ï†úÏ∂ú Ïã§Ìå®:", err);
    })
  
    setChatInput("");
  };

  const playersWithScores = players.map((player) => ({
    ...player,
    score: gameState.scores[player.id] || 0,
  }));

  return (
    <div className="w-full min-h-screen p-4 relative overflow-hidden">
      {/* ÎùºÏö¥Îìú Ï†ïÎ≥¥ Ïò§Î•∏Ï™Ω ÏúÑ (Ïª¥Ìè¨ÎÑåÌä∏ ÎÇ¥Î∂Ä) */}
      <div className="absolute top-8 right-6 z-40 bg-white/80 rounded-xl px-5 py-2 shadow-lg text-lg font-bold text-blue-700 border border-blue-200">
        Round {gameState.currentRound} / {gameState.maxRound}
      </div>

      {/* ÌååÌã∞ÌÅ¥ Ìö®Í≥º */}
      <AnimatePresence>
        {gameState.showParticles && particles.map((particle) => (
          <motion.div
            key={particle.id}
            className="absolute w-3 h-3 rounded-full pointer-events-none"
            style={{
              left: particle.x,
              top: particle.y,
              backgroundColor: particle.color,
            }}
            initial={{ opacity: 1, scale: 0 }}
            animate={{ opacity: 0, scale: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 1 }}
          />
        ))}
      </AnimatePresence>

      {/* Ï†êÏàò Ïï†ÎãàÎ©îÏù¥ÏÖò */}
      <AnimatePresence>
        {gameState.scoreAnimations.map((animation) => (
          <motion.div
            key={animation.id}
            className="absolute pointer-events-none z-50"
            style={{ left: animation.x, top: animation.y }}
            initial={{ opacity: 0, y: 0, scale: 0.5 }}
            animate={{ opacity: 1, y: -100, scale: 1.5 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 2, ease: "easeOut" }}
          >
            <div className="text-2xl font-bold text-yellow-400 drop-shadow-lg">
              +{animation.score}
            </div>
          </motion.div>
        ))}
      </AnimatePresence>

      {/* Î°úÎ¥á Ï∫êÎ¶≠ÌÑ∞ */}
      {/* Î°úÎ¥á Ï∫êÎ¶≠ÌÑ∞ */}

      {/* ÌûåÌä∏ Ï§ëÏïô ÌåùÏóÖ ‚Üí Î°úÎ¥á Ïò§Î•∏Ï™ΩÏúºÎ°ú Ïù¥Îèô ÌõÑ Í≥†Ï†ï */}
      <AnimatePresence>
        {showHintAnimation && (
          <motion.div
            key="hint-popup"
            initial={{
              position: "fixed",
              top: "50%",
              left: "50%",
              x: "-50%",
              y: "-50%",
              scale: 1.5,
              opacity: 1,
              zIndex: 100
            }}
            animate={{
              top: 250, // Ìó§Îçî(Î°úÎ¥á) ÏïÑÎûò Í≥†Ï†ï ÏúÑÏπò (px)
              left: '50%',
              x: "-50%",
              y: "0%",
              scale: 1,
              opacity: 0.95
            }}
            exit={{ opacity: 0 }}
            transition={{
              duration: 1.5,
              ease: "easeInOut",
              times: [0, 0.7, 1],
              opacity: { duration: 2, times: [0, 0.7, 1] }
            }}
            className="max-w-[340px] text-2xl font-extrabold text-white bg-gradient-to-r from-blue-600 to-purple-600 px-5 py-3 rounded-2xl shadow-2xl whitespace-nowrap pointer-events-none border-4 border-yellow-200"
          >
            {showHintAnimation}
          </motion.div>
        )}
      </AnimatePresence>
      {/* Í≥†Ï†ï ÌûåÌä∏ Î∞ïÏä§ (Î°úÎ¥á ÏïÑÎûò) */}
      {fixedHint && !showHintAnimation && (
        <div
          className="fixed z-30"
          style={{
            top: 250,
            left: '50%',
            transform: 'translateX(-50%)',
          }}
        >
          <div className="max-w-[340px] text-2xl font-extrabold text-white bg-gradient-to-r from-blue-600 to-purple-600 px-5 py-3 rounded-2xl shadow-2xl whitespace-nowrap border-4 border-yellow-200">
            {fixedHint}
          </div>
        </div>
      )}

      <div className="max-w-7xl mx-auto relative z-10">
        <div style={{ position: 'relative' }}>
          <GameHeader
            currentRound={gameState.currentRound}
            maxRound={gameState.maxRound}
            isReading={gameState.isReading}
            onBack={onBack}
          />
          {/* Ïò§Î•∏Ï™Ω ÌïòÎã® 60Ï¥à ÌÉÄÏù¥Î®∏+Í≤åÏù¥ÏßÄÎ∞î */}
          <div style={{ position: 'absolute', right: 40, bottom: 24, width: 180, zIndex: 30 }} className="flex flex-col items-end">
            <div className="text-3xl font-extrabold text-white mb-1 drop-shadow-lg">{gameState.timeLeft}Ï¥à</div>
            <div className="w-full h-3 bg-gray-200 rounded-full overflow-hidden">
              <div
                className="h-3 bg-gradient-to-r from-blue-400 to-red-400 transition-all duration-500"
                style={{ width: `${(gameState.timeLeft / 60) * 100}%` }}
              />
            </div>
          </div>
        </div>




        {/* Ï†ïÎãµ ÌëúÏãú */}
        <AnimatePresence>
          {gameState.showCorrectAnswer && gameState.correctAnswer && (
            <motion.div
              className="fixed inset-0 flex items-center justify-center z-50 pointer-events-none"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.5 }}
            >
              <div className="bg-green-500 rounded-3xl shadow-2xl border-4 border-yellow-300 p-8">
                <div className="text-center">
                  <h2 className="text-3xl font-bold text-white mb-3 drop-shadow-lg">
                    {gameState.correctAnswer}
                  </h2>
                  <p className="text-xl text-white font-semibold mb-4">
                    {gameState.correctArtist}
                  </p>
                  <motion.div
                    className="text-lg text-white font-semibold"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    transition={{ delay: 0.5, duration: 0.5 }}
                  >
                    {(() => {
                      const winner = players.find(p => String(p.id) === String(gameState.roundWinner));
                      console.log('Ï†ïÎãµÏ∞Ω - roundWinner:', gameState.roundWinner);
                      console.log('Ï†ïÎãµÏ∞Ω - Ï∞æÏùÄ ÌîåÎ†àÏù¥Ïñ¥:', winner);
                      console.log('Ï†ïÎãµÏ∞Ω - ÎãâÎÑ§ÏûÑ:', winner?.nickname);
                      console.log('Ï†ïÎãµÏ∞Ω - ÌîåÎ†àÏù¥Ïñ¥ IDÎì§:', players.map(p => ({ id: p.id, type: typeof p.id })));
                      return winner?.nickname ? `${winner.nickname}ÎãòÏù¥ ÎßûÏ∑ÑÏäµÎãàÎã§!` : 'Ï†ïÎãµÏûÖÎãàÎã§!';
                    })()}
                  </motion.div>
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <div>
            <GameScoreboard players={playersWithScores} />
          </div>
          <div className="lg:col-span-2">
            <GameChat
              messages={chatMessages}
              chatInput={chatInput}
              isReading={gameState.isReading}
              onChatInputChange={setChatInput}
              onChatSubmit={handleChatSubmit}
            />
          </div>
        </div>
        <GameResultModal
          isOpen={showResults}
          players={playersWithScores}
          onClose={handleCloseResult}
        />
      </div>
    </div>
  );
};

export default FlatLyricsGame;
