// components/game/RandomSongGame.tsx
import { useState, useEffect, useRef, useCallback } from "react";
import { useRouter } from "next/navigation";
import { motion } from "framer-motion";
import api from "@/lib/api";
import { sendGameMessage, sendKeywordConfirm, disconnectGameSocket } from "@/lib/gameSocket";
import { PREDEFINED_TAGS } from "@/lib/tags";
import GameResultModal from "@/components/game/GameResultModal";
import { Card } from "@/components/ui/Card";
import {
  Dialog,
  DialogContent,
} from "@/components/ui/dialog";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";

// ÌõÖÎì§ import
import { useGameConnection } from "@/hooks/useGameConnection";
import { useGameState } from "@/hooks/useGameState";

// Ïª¥Ìè¨ÎÑåÌä∏Îì§ import
import { WaitingRoom } from "@/components/RandomSongGame/RandomSongWaitingRoom"
import { PlayingScreen } from "@/components/RandomSongGame/RandomSongPlayingScreen";
import { ConnectionModal } from "@/components/RandomSongGame/ConnectionModal";

interface RandomSongGameProps {
  user: any;
  room: any;
  players: any[];
  onBack: () => void;
  onGameEnd: (results: any[]) => void;
  onGameStart?: () => void;
  isAISongGame?: boolean;
  onPlayersUpdate?: (players: any[]) => void;
}

const RandomSongGame = ({
  user,
  room,
  players,
  onBack,
  onGameEnd,
  isAISongGame,
  onGameStart,
  onPlayersUpdate,
}: RandomSongGameProps) => {
  const router = useRouter();
  const audioRef = useRef<HTMLAudioElement>(null);
  
  // ÏÉÅÌÉú Í¥ÄÎ¶¨
  const {
    gameSession,
    setGameSession,
    loading,
    setLoading,
    phase,
    setPhase,
    countdown,
    roundTimer,
    setRoundTimer,
    chatMessages,
    setChatMessages,
    showAnswerModal,
    setShowAnswerModal,
    answerModalData,
    setAnswerModalData,
    showGameEndModal,
    setShowGameEndModal,
    showNoAnswerModal,
    setShowNoAnswerModal,
    noAnswerModalContent,
    showRoundNotification,
    showHintAnimation,
    setShowHintAnimation,
    winnerAnimatedScore,
    setWinnerAnimatedScore,
    progress,
    setProgress,
    selectedTagIds,
    setSelectedTagIds,
    isKeywordConfirmed,
    setIsKeywordConfirmed,
    roundTimerIntervalRef,
    currentRoundRef,
    maxRoundRef,
    gameHandlers,
    resetGameState
  } = useGameState();

  // Ï∂îÍ∞Ä ÏÉÅÌÉúÎì§
  const [hasUserInteractedForAudio, setHasUserInteractedForAudio] = useState<boolean>(false);
  const [showLeaveModal, setShowLeaveModal] = useState(false);
  const [leaveModalMessage, setLeaveModalMessage] = useState('');
  const [showLeaveConfirmModal, setShowLeaveConfirmModal] = useState(false);
  const [playersState, setPlayersState] = useState(players);
  const isBlockingRef = useRef(true);
  const [showReconnectSuccess, setShowReconnectSuccess] = useState<string | null>(null);
  const isHost = user.id === room.hostId;
  

  // Í≤åÏûÑ Ïó∞Í≤∞ Í¥ÄÎ¶¨
  const {
    socketConnected,
    showConnectionModal,
    isReconnecting,
    handleManualReconnect,
    handleLeaveToLobby,
  } = useGameConnection({
    roomId: room.roomId,
    phase,
    ...gameHandlers,
    onReconnectSuccess: () => {
      console.log("üéâ onReconnectSuccess ÏΩúÎ∞± Ìò∏Ï∂úÎê®!");
      // Ïû¨Ïó∞Í≤∞ ÏÑ±Í≥µ Ïãú Î©îÏãúÏßÄ ÌëúÏãú
      setShowReconnectSuccess("üîÑ Ïû¨Ïó∞Í≤∞ ÏôÑÎ£å!");
      console.log("‚úÖ showReconnectSuccess ÏÉÅÌÉú ÏÑ§Ï†ïÎê®:", "Ïû¨Ïó∞Í≤∞ ÏÑ±Í≥µ Î©îÏãúÏßÄ");
      setTimeout(() => {
        setShowReconnectSuccess(null);
        console.log("‚è∞ showReconnectSuccess ÏÉÅÌÉú Ï¥àÍ∏∞ÌôîÎê®");
      }, 4000);
    },
    onMessage: (msg: any) => {
      
      if (msg.type === "PLAYER_UPDATE") {
        onPlayersUpdate?.(msg.players);
        console.log("Player update received:", msg.players);
      } else if (
        msg.messageType === "TALK" ||
        msg.messageType === "ENTER" ||
        msg.messageType === "LEAVE"
      ) {
        setChatMessages((prev) => [...prev, msg]);
      }
    },
  });

  // Players ÏÉÅÌÉú ÎèôÍ∏∞Ìôî
  useEffect(() => {
    setPlayersState(players);
  }, [players]);

  // ÌÇ§Î≥¥Îìú ÏûÖÎ†• Ïãú Ï±ÑÌåÖÏ∞Ω ÏûêÎèô Ìè¨Ïª§Ïä§
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      // Í≤åÏûÑ Ï§ëÏù¥Í≥†, ÏûÖÎ†•Ï∞ΩÏù¥ Ìè¨Ïª§Ïä§ Ïïà ÎêòÏñ¥ ÏûàÏùÑ Îïå
      if (phase === "playing") {
        const activeElement = document.activeElement;
        const isInputFocused = activeElement?.tagName === 'INPUT' || activeElement?.tagName === 'TEXTAREA';
        
        // ÌäπÏàòÌÇ§Í∞Ä ÏïÑÎãå ÏùºÎ∞ò Î¨∏Ïûê ÏûÖÎ†•Ïãú
        if (!isInputFocused && e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
          const chatInput = document.querySelector('input[placeholder*="Î©îÏãúÏßÄ"], input[placeholder*="Ï±ÑÌåÖ"], textarea') as HTMLInputElement | HTMLTextAreaElement;
          if (chatInput) {
            chatInput.focus();
          }
        }
      }
    };

    document.addEventListener("keydown", handleKeyPress);
    return () => document.removeEventListener("keydown", handleKeyPress);
  }, [phase]);

  // Í≤åÏûÑ ÌîåÎ†àÏù¥ ÌôîÎ©¥ÏóêÏÑú Ï±ÑÌåÖÏ∞Ω Ìè¨Ïª§Ïä§
  useEffect(() => {
    if (phase === "playing") {
      setTimeout(() => {
        const chatInput = document.querySelector('input[placeholder*="Î©îÏãúÏßÄ"], input[placeholder*="Ï±ÑÌåÖ"], textarea') as HTMLInputElement | HTMLTextAreaElement;
        if (chatInput) {
          chatInput.focus();
        }
      }, 100);
    }
  }, [phase]);

  // Îí§Î°úÍ∞ÄÍ∏∞/ÏÉàÎ°úÍ≥†Ïπ® Ï∞®Îã®
  useEffect(() => {
    if (phase === 'playing' || phase === 'countdown') {
      isBlockingRef.current = true;
      
      const handlePopState = (e: PopStateEvent) => {
        if (!isBlockingRef.current) return;
        
        setTimeout(() => {
          window.history.pushState(null, '', window.location.href);
        }, 0);
        
        setShowLeaveConfirmModal(true);
      };

      const handleBeforeUnload = (e: BeforeUnloadEvent) => {
        if (!isBlockingRef.current) return;
        
        e.preventDefault();
        e.returnValue = 'Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§. Ï†ïÎßêÎ°ú ÎÇòÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?';
        return 'Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§. Ï†ïÎßêÎ°ú ÎÇòÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?';
      };

      window.history.pushState(null, '', window.location.href);
      window.addEventListener('popstate', handlePopState);
      window.addEventListener('beforeunload', handleBeforeUnload);

      return () => {
        window.removeEventListener('popstate', handlePopState);
        window.removeEventListener('beforeunload', handleBeforeUnload);
        isBlockingRef.current = false;
      };
    } else {
      isBlockingRef.current = false;
    }
  }, [phase]);

  // Ïò§ÎîîÏò§ Ïû¨ÏÉù Í¥ÄÎ¶¨
  useEffect(() => {
    if (
      phase === "playing" &&
      gameSession?.currentSong?.audioUrl &&
      audioRef.current
    ) {
      audioRef.current.src = gameSession.currentSong.audioUrl;
      audioRef.current.load();
      audioRef.current
        .play()
        .then(() => {
          setHasUserInteractedForAudio(true);
        })
        .catch((e) => {
          if (e.name === "NotAllowedError") {
            setHasUserInteractedForAudio(false);
          }
        });
    } else if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
    }
  }, [phase, gameSession?.currentSong?.audioUrl]);

  // ÌûåÌä∏ Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î∞ç
  useEffect(() => {
    if (
      phase !== "playing" ||
      !gameSession?.serverStartTime ||
      !gameSession?.currentSong ||
      showAnswerModal
    ) return;

    const elapsed = Date.now() - gameSession.serverStartTime;
    const timeLeft = Math.max(0, 30 - Math.floor(elapsed / 1000));

    if (timeLeft === 20 && !showHintAnimation) {
      setShowHintAnimation(`üé§ Í∞ÄÏàò: ${gameSession.currentSong.artist}`);
      setTimeout(() => setShowHintAnimation(null), 2000);
    }

    if (timeLeft === 10 && !showHintAnimation) {
      setShowHintAnimation(`üí° Ï†úÎ™© ÌûåÌä∏: ${gameSession.currentSong.hint}`);
      setTimeout(() => setShowHintAnimation(null), 2000);
    }
  }, [phase, roundTimer, gameSession?.serverStartTime, gameSession?.currentSong, showHintAnimation]);

  // Ìö®Í≥ºÏùå Ïû¨ÏÉù
  useEffect(() => {
    if (phase === "countdown" && countdown > 0) {
      const countdownSound = new Audio("/audio/countdown_ssg.mp3");
      countdownSound.volume = 0.6;
      countdownSound.play().catch(console.error);
    }
  }, [phase]);

  useEffect(() => {
    if (phase === "final") {
      const finalSound = new Audio("/audio/final.wav");
      finalSound.volume = 0.7;
      finalSound.play().catch(console.error);
    }
  }, [phase]);

  useEffect(() => {
    if (showAnswerModal) {
      const correctSound = new Audio("/audio/ai.wav");
      correctSound.volume = 0.5;
      correctSound.play().catch(console.error);
    }
  }, [showAnswerModal]);

  useEffect(() => {
    if (showNoAnswerModal) {
      const failSound = new Audio("/audio/fail.mp3");
      failSound.volume = 0.5;
      failSound.play().catch(console.error);
    }
  }, [showNoAnswerModal]);

  // ÏûÖÏû• Ìö®Í≥ºÏùå
  useEffect(() => {
    const audio = new Audio("/audio/entersound.wav");
    audio.play().catch(console.error);
  }, []);

  // Ï†ïÎãµÏûê Ï†êÏàò Ïï†ÎãàÎ©îÏù¥ÏÖò
  const winner = players.find(p => p.nickname === answerModalData?.winnerNickname);
  const winnerScore = gameSession?.playerScores?.[winner?.id] ?? 0;

  useEffect(() => {
    if (showAnswerModal && winnerScore > 0 && winner) {
      const start = winner.score ?? 0;
      const end = winnerScore;
      let current = start;
      const step = Math.ceil((end - start) / 15);
      
      const interval = setInterval(() => {
        current += step;
        if (current >= end) {
          current = end;
          clearInterval(interval);
        }
        setWinnerAnimatedScore(current);
      }, 30);

      return () => clearInterval(interval);
    }
  }, [showAnswerModal, winnerScore, winner]);

  // ÌîÑÎ°úÍ∑∏Î†àÏä§Î∞î Ïï†ÎãàÎ©îÏù¥ÏÖò
  useEffect(() => {
    if (!showNoAnswerModal) return;

    let frameId: number;
    const duration = 2500;
    let startTime: number | null = null;

    const step = (timestamp: number) => {
      if (startTime === null) startTime = timestamp;
      const elapsed = timestamp - startTime;
      const value = Math.min((elapsed / duration) * 100, 100);
      setProgress(value);

      if (elapsed < duration) {
        frameId = requestAnimationFrame(step);
      }
    };

    setProgress(0);
    frameId = requestAnimationFrame(step);

    return () => cancelAnimationFrame(frameId);
  }, [showNoAnswerModal]);

  // Ìï∏Îì§Îü¨ Ìï®ÏàòÎì§
  const handleSendMessage = async (message: string) => {
    const trimmed = message.trim();
    if (!trimmed) return;

    sendGameMessage(room.roomId, user.id, user.nickname, trimmed);

    if (phase === "playing") {
      try {
        await api.post(`/api/game-session/${room.roomId}/answer`, {
          answer: trimmed,
        });
      } catch (err) {
        console.error("Ï†ïÎãµ Ï†úÏ∂ú Ïã§Ìå®:", err);
      }
    }
  };

  const handleStartGame = async () => {
    const keywordNames = selectedTagIds
      .map((id) => PREDEFINED_TAGS.find((tag) => tag.id === id)?.name)
      .filter((name): name is string => !!name);

    try {
      await api.post(`/api/game-session/${room.roomId}/start`, {
        keywords: keywordNames,
      });
      setLoading(false);
    } catch (error) {
      console.error("Í≤åÏûÑ ÏãúÏûë Ïã§Ìå®:", error);
    }
  };

  const handleKeywordConfirm = () => {
    sendKeywordConfirm(room.roomId, selectedTagIds);
    setIsKeywordConfirmed(true);
  };

  const handlePlayAudio = () => {
    if (audioRef.current) {
      audioRef.current
        .play()
        .then(() => {
          setHasUserInteractedForAudio(true);
        })
        .catch(console.error);
    }
  };

  const handleLeaveRoom = () => {
    const gameInProgress = phase === 'playing' || phase === 'countdown';
    let confirmMessage = 'Î∞©ÏùÑ ÎÇòÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?';
    
    if (gameInProgress) {
      confirmMessage = room.roomType === "QUICK_MATCH" 
        ? 'Îπ†Î•∏ÎåÄÏ†ÑÏùÑ Ï¢ÖÎ£åÌïòÏãúÍ≤†ÏäµÎãàÍπå? Í≤∞Í≥ºÍ∞Ä Ï†ÄÏû•Îê©ÎãàÎã§.'
        : 'Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§. ÎÇòÍ∞ÄÏãúÎ©¥ Í≤åÏûÑÏóêÏÑú Ï†úÏô∏Îê©ÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?';
    }
    
    setLeaveModalMessage(confirmMessage);
    setShowLeaveModal(true);
  };

  const confirmLeaveRoom = async () => {
    try {
      if (roundTimerIntervalRef.current) {
        clearInterval(roundTimerIntervalRef.current);
      }

      if (room.roomType === "QUICK_MATCH") {
        await api.post("/api/quick-match/end", null, {
          params: { roomCode: room.roomCode },
        });

        const resultRes = await api.get("/api/quick-match/result", {
          params: { roomCode: room.roomCode },
        });

        localStorage.setItem("quickMatchResult", JSON.stringify(resultRes.data));
        router.push("/lobby");
      } else {
        await api.delete(`/api/room/${room.roomId}/leave`);
        router.push("/lobby");
      }
    } catch (error) {
      console.error("Î∞© ÎÇòÍ∞ÄÍ∏∞ Ïã§Ìå®:", error);
      router.push("/lobby");
    } finally {
      setShowLeaveModal(false);
    }
  };


  const handleConfirmLeave = () => {
    isBlockingRef.current = false;
    setShowLeaveConfirmModal(false);
    
    setTimeout(() => {
      router.push('/lobby');
    }, 100);
  };

  const handleStayInGame = () => {
    setShowLeaveConfirmModal(false);
    
    setTimeout(() => {
      if (isBlockingRef.current) {
        window.history.pushState(null, '', window.location.href);
      }
    }, 100);
  };

  const handleCloseResult = async () => {
    setShowGameEndModal(false);
    try {
      await api.delete(`/api/room/${room.roomId}/leave`);
    } catch (e) {
      // Ïã§Ìå®Ìï¥ÎèÑ Î°úÎπÑÎ°ú Ïù¥Îèô
    }
    window.location.href = "/lobby";
  };

  const playersWithFinalScores = players.map((player) => ({
    ...player,
    score: gameSession?.playerScores?.[player.id] || 0,
  }));

  // Í∞ïÏ†ú Ïó∞Í≤∞ ÎÅäÍ∏∞ Ìï®Ïàò (ÌÖåÏä§Ìä∏Ïö©)
  const handleForceDisconnect = useCallback(() => {
    console.log("üß™ LPÌåê ÌÅ¥Î¶≠Îê® - Ïó∞Í≤∞ ÎÅäÍ∏∞ ÏãúÎèÑ");
    
    try {
      disconnectGameSocket();
      console.log("‚úÖ disconnectGameSocket() Ìò∏Ï∂ú ÏôÑÎ£å");
    } catch (error) {
      console.error("‚ùå disconnectGameSocket() Ìò∏Ï∂ú Ïã§Ìå®:", error);
    }
  }, []);

  // Î°úÎî© Ï§ë
  if (loading) {
    return <div className="min-h-screen flex items-center justify-center">Î°úÎî© Ï§ë...</div>;
  }

  // PhaseÎ≥Ñ Î†åÎçîÎßÅ
  if (phase === "waiting") {
    return (
      <>
        <WaitingRoom
          user={user}
          room={room}
          players={playersState}
          selectedTagIds={selectedTagIds}
          isKeywordConfirmed={isKeywordConfirmed}
          chatMessages={chatMessages}
          onLeaveRoom={handleLeaveRoom}
          onStartGame={handleStartGame}
          onKeywordConfirm={handleKeywordConfirm}
          onTagSelectionChange={(newSelectedIds) => {
            setSelectedTagIds(newSelectedIds);
            setIsKeywordConfirmed(false);
          }}
          onSendMessage={handleSendMessage}
        />
        <LeaveModal 
          show={showLeaveModal}
          message={leaveModalMessage}
          onCancel={() => setShowLeaveModal(false)}
          onConfirm={confirmLeaveRoom}
        />
      </>
    );
  }

  if (phase === "countdown") {
    return (
      <>
        <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-cyan-400 via-blue-500 via-purple-500 to-pink-500 p-4">
          <Card className="bg-white/90 backdrop-blur-sm p-6 lg:p-12 text-center max-w-sm lg:max-w-none">
            <div className="text-6xl lg:text-8xl font-bold text-transparent bg-gradient-to-r from-cyan-500 via-blue-500 to-purple-500 bg-clip-text mb-4">
              {countdown}
            </div>
            <div className="text-lg lg:text-2xl font-semibold text-gray-700">
              Í≤åÏûÑÏù¥ Í≥ß ÏãúÏûëÎê©ÎãàÎã§!
            </div>
          </Card>
        </div>
        <ConnectionModal
          show={showConnectionModal}
          isReconnecting={isReconnecting}
          onReconnect={handleManualReconnect}
          onLeaveToLobby={handleLeaveToLobby}
        />
        <LeaveConfirmModal
          show={showLeaveConfirmModal}
          onStay={handleStayInGame}
          onLeave={handleConfirmLeave}
        />
      </>
    );
  }

  if (phase === "playing") {
    return (
      <>
        <PlayingScreen
          user={user}
          gameSession={gameSession}
          roundTimer={roundTimer}
          players={playersState}
          chatMessages={chatMessages}
          showRoundNotification={showRoundNotification}
          showHintAnimation={showHintAnimation}
          showReconnectSuccess={showReconnectSuccess}
          hasUserInteractedForAudio={hasUserInteractedForAudio}
          onLeaveRoom={handleLeaveRoom}
          onSendMessage={handleSendMessage}
          onPlayAudio={handlePlayAudio}
          onForceDisconnect={handleForceDisconnect}
          audioRef={audioRef}
        />

        {/* Ï†ïÎãµ Î™®Îã¨ */}
        <AnswerModal
          show={showAnswerModal}
          data={answerModalData}
          winner={winner}
          animatedScore={winnerAnimatedScore}
        />

        {/* Ïò§Îãµ Î™®Îã¨ */}
        <NoAnswerModal
          show={showNoAnswerModal}
          content={noAnswerModalContent}
        />

        <ConnectionModal
          show={showConnectionModal}
          isReconnecting={isReconnecting}
          onReconnect={handleManualReconnect}
          onLeaveToLobby={handleLeaveToLobby}
        />

        <LeaveModal 
          show={showLeaveModal}
          message={leaveModalMessage}
          onCancel={() => setShowLeaveModal(false)}
          onConfirm={confirmLeaveRoom}
        />

        <LeaveConfirmModal
          show={showLeaveConfirmModal}
          onStay={handleStayInGame}
          onLeave={handleConfirmLeave}
        />
      </>
    );
  }

  // Final phase
  return (
    <div className="min-h-screen p-2 md:p-4 bg-gradient-to-br from-cyan-400 via-blue-500 via-purple-500 to-pink-500">
      <GameResultModal
        isOpen={showGameEndModal}
        players={playersWithFinalScores}
        onClose={handleCloseResult}
        onRestart={resetGameState}
        gameType="random"
        onLeaveRoom={confirmLeaveRoom}
      />
    </div>
  );
};

// ÏÑúÎ∏å Î™®Îã¨ Ïª¥Ìè¨ÎÑåÌä∏Îì§
const LeaveModal = ({ show, message, onCancel, onConfirm }: {
  show: boolean;
  message: string;
  onCancel: () => void;
  onConfirm: () => void;
}) => {
  if (!show) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-xl p-6 max-w-md w-full shadow-2xl">
        <div className="text-center">
          <div className="text-2xl mb-4">üö™</div>
          <h3 className="text-lg font-bold text-gray-900 mb-3">Î∞© ÎÇòÍ∞ÄÍ∏∞</h3>
          <p className="text-gray-600 mb-6 leading-relaxed">{message}</p>
          <div className="flex gap-3">
            <button
              onClick={onCancel}
              className="flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition-colors"
            >
              Ï∑®ÏÜå
            </button>
            <button
              onClick={onConfirm}
              className="flex-1 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors"
            >
              ÎÇòÍ∞ÄÍ∏∞
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

const LeaveConfirmModal = ({ show, onStay, onLeave }: {
  show: boolean;
  onStay: () => void;
  onLeave: () => void;
}) => {
  if (!show) return null;

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-xl p-6 max-w-md w-full shadow-2xl">
        <div className="text-center">
          <div className="text-4xl mb-4">‚ö†Ô∏è</div>
          <h3 className="text-xl font-bold text-gray-900 mb-3">
            Í≤åÏûÑÏùÑ ÎÇòÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?
          </h3>
          <p className="text-gray-600 mb-6 leading-relaxed">
            Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§.<br/>
            ÎÇòÍ∞ÄÏãúÎ©¥ Í≤åÏûÑÏóêÏÑú Ï†úÏô∏ÎêòÎ©∞ Ï†êÏàòÍ∞Ä Ï†ÄÏû•ÎêòÏßÄ ÏïäÏäµÎãàÎã§.
          </p>
          <div className="flex gap-3">
            <button
              onClick={onStay}
              className="flex-1 px-4 py-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition-colors font-medium"
            >
              Í≥ÑÏÜç Í≤åÏûÑÌïòÍ∏∞
            </button>
            <button
              onClick={onLeave}
              className="flex-1 px-4 py-3 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors font-medium"
            >
              ÎÇòÍ∞ÄÍ∏∞
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

const AnswerModal = ({ show, data, winner, animatedScore }: {
  show: boolean;
  data: any;
  winner: any;
  animatedScore: number;
}) => {
  if (!show || !data) return null;

  return (
    <Dialog open={show} onOpenChange={() => {}}>
      <DialogContent className="max-w-[90vw] sm:max-w-[425px] text-center mx-auto">
        <motion.div
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ duration: 0.4 }}
          className="flex flex-col items-center"
        >
          <div className="text-3xl lg:text-4xl font-bold text-green-600 mb-2">
            üéâ Ï†ïÎãµÏûÖÎãàÎã§!
          </div>
          {winner && (
            <div className="flex flex-col items-center gap-2">
              <Avatar className="w-16 h-16 lg:w-20 lg:h-20">
                <AvatarImage src={winner.avatar} />
                <AvatarFallback>{winner.nickname[0]}</AvatarFallback>
              </Avatar>
              <div className="text-lg lg:text-xl font-semibold text-purple-800">
                {winner.nickname} ÎãòÏù¥ Ï†ïÎãµÏùÑ ÎßûÏ∑ÑÏñ¥Ïöî!
              </div>
              <div className="flex flex-col items-center gap-2 relative">
                <motion.div
                  initial={{ opacity: 1, y: 0, scale: 1 }}
                  animate={{ opacity: 0, y: -40, scale: 1.3 }}
                  transition={{ duration: 2.0, ease: "easeOut" }}
                  className="absolute -top-6 lg:-top-8 ml-[100px] lg:ml-[150px] text-lg lg:text-xl font-bold text-yellow-400 drop-shadow-md z-10"
                >
                  +{data?.scoreGain ?? 0}Ï†ê!
                </motion.div>
                <div className="text-xl lg:text-2xl font-bold text-blue-700">
                  ÌòÑÏû¨ Ï†êÏàò: {animatedScore}Ï†ê
                </div>
              </div>
            </div>
          )}
          <div className="mt-4 text-base lg:text-lg text-gray-700">
            Ï†ïÎãµ: "{data?.correctTitle}"
          </div>
          <p className="text-xs lg:text-sm text-gray-500 mt-2">
            Îã§Ïùå ÎùºÏö¥ÎìúÎ°ú Ïù¥Îèô Ï§ë...
          </p>
        </motion.div>
      </DialogContent>
    </Dialog>
  );
};

const NoAnswerModal = ({ show, content }: {
  show: boolean;
  content: { title: string; subtitle: string };
}) => {
  if (!show) return null;

  return (
    <Dialog open={show} onOpenChange={() => {}}>
      <DialogContent className="max-w-[90vw] sm:max-w-[425px] text-center mx-auto">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.4 }}
        >
          <motion.div
            className="text-3xl lg:text-4xl mb-2"
            animate={{ y: [0, -5, 0] }}
            transition={{
              duration: 1,
              repeat: Infinity,
              repeatType: "loop",
              ease: "easeInOut",
            }}
          >
            üò¢
          </motion.div>
          <h2 className="text-lg lg:text-xl font-bold text-red-600">
            Ï†ïÎãµÏûêÍ∞Ä ÏóÜÏäµÎãàÎã§!
          </h2>
          <p className="text-sm lg:text-base text-gray-600 mt-2">
            Ï†ïÎãµ: "<span className="text-blue-600 font-semibold">{content.subtitle}</span>"
          </p>
          <div className="mt-6">
            <p className="text-xs lg:text-sm text-gray-500 mt-1">
              3Ï¥à ÌõÑ Îã§Ïùå ÎùºÏö¥ÎìúÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§...
            </p>
          </div>
        </motion.div>
      </DialogContent>
    </Dialog>
  );
};

export default RandomSongGame;